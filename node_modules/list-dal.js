// require modules
var mongo  = require('mongoskin'),
    amanda = require('amanda'),
    moment = require('moment');

// configure mongodb connection via mongoskin
var db = mongo.db('mongodb://ctlnodeworker:worker10112013@paulo.mongohq.com:10091/app19351386');
db.bind('lists');
db.lists.ensureIndex({ alias: 1 });


// configure amanda schema and validator
var schema = {
    title           : "input validation",
    description     : "using node.js module amanda to ensure that the text isn't too long",
    type: 'string',
    minLength: 1,
    maxLength: 80
};
var options = {
    singleError: false
};
var validator = amanda('json');


// set up a module functionset object
var store = {
    find: function(callback) {
        db.lists.find().toArray(callback);
    },
    findOne: function(alias, callback) {
        db.lists.findOne({ alias: alias }, callback);
    },
    create: function(alias, callback) {
        db.lists.insert({ alias: alias, creationMoment: moment().format('L'), expireMoment: moment().add('days', 7).format('L'), tasks: [] }, callback);
    },
    delete: function (alias, callback) {
        db.lists.remove({ alias: alias }, callback);
    },
    addTask: function (alias, description, callback) {
        // first of all: check user input on server side to ensure too long strings will be persisted
        validator.validate(description, schema, options, function (err) {
            if (err) {
                for (var i = 0; i < err.length; i++) {
                    logEvent(err[i].message);
                }
            } else {
                var idSeq = 0,
            newTask,
            updatedTasks;

                // (1) find list by alias
                db.lists.findOne({ alias: alias }, function (err, result) {
                    updatedTasks = result.tasks;

                    // (2) find current maximum id and retrieve max+1
                    for (var i = 0; i < updatedTasks.length; i++) {
                        if (idSeq <= updatedTasks[i].id) {
                            idSeq = updatedTasks[i].id + 1;
                        }
                    }

                    // (3) add new task to temporary saved task-array
                    newTask = { id: idSeq, state: 'todo', description: description };
                    updatedTasks.push(newTask);

                    // (4) do update with extended task-array now
                    db.lists.update({ alias: alias }, { $set: { tasks: updatedTasks } }, { multi: false }, function (err, result) {
                        if (err) {
                            console.log(err);
                        } else {
                            callback(newTask);
                        }
                    });
                });
            }
            
        });
    },
    removeTask: function (alias, id, callback) {
        var updatedTasks;

        // (1) find list by alias
        db.lists.findOne({ alias: alias }, function (err, result) {
            updatedTasks = result.tasks;

            // (2) search for task and remove it from temporary task-array
            for (var i = 0; i < updatedTasks.length; i++) {
                if (updatedTasks[i].id == id) {
                    updatedTasks.splice(i, 1);
                    break;
                }
            }

            // (3) do update with updated task-array now
            db.lists.update({ alias: alias }, { $set: { tasks: updatedTasks } }, { multi: false }, function (err, result) {
                if (err) {
                    console.log(err);
                } else {
                    callback();
                }
            });
            
        });
    },
    changeTaskState: function (alias, id, state, callback) {
        var changedTask,
            updatedTasks;

        // (1) find list by alias
        db.lists.findOne({ alias: alias }, function (err, result) {
            updatedTasks = result.tasks;

            // (2) search for task and change its state
            for (var i = 0; i < updatedTasks.length; i++) {
                if (updatedTasks[i].id == id) {
                    updatedTasks[i].state = state;
                    changedTask = updatedTasks[i];
                    break;
                }
            }

            // (3) do update with updated task-array now
            db.lists.update({ alias: alias }, { $set: { tasks: updatedTasks } }, { multi: false }, function (err, result) {
                if (err) {
                    console.log(err);
                } else {
                    callback(changedTask);
                }
            });
        });
    }
};

// export the function containing object
// and enable them when requiring the module
module.exports = store;

function logEvent(msg) {
    console.log("CTLNODE-DAL: " + msg);
}